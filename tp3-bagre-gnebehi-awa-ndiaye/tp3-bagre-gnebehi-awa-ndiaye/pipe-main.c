#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <getopt.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/wait.h>
#include "pipe-common.h"
#include "pipe-message.h"

void help();
void version();

int main(int argc, char **argv)
{
	static struct option long_options[] =
	{
		{"help", no_argument, NULL, 'h'},
		{"version", no_argument, NULL, 'v'},
		{"times-for-sending", required_argument, NULL, 'u'},
		{"times-for-receiving", required_argument, NULL, 't'},
		{"seconds-for-sending", required_argument, NULL, 's'},
		{"seconds-for-receiving", required_argument, NULL, 'r'},
		{"message-text", required_argument, NULL, 'x'}
    };

	int c;
	int option_index = 0;
	char text[64];
	int secR, secS;
	int timesR, timesS;
	pipe_message_t *myStruct = malloc(sizeof(pipe_message_t));
	int pipefd[2];
	int FLAG;
	pid_t cpid;
	FLAG = O_NONBLOCK;
	strcpy(text,"This is the default message text");
	secS = 1;
	secR = 1;
	timesR = -1;
	timesS = 1;

	while (1)
	{
		c = getopt_long(argc, argv, "r:u:s:t:x:hv", long_options, &option_index);
		if (c == -1)
			break;

		switch (c)
		{
			case 'h':
				help();
				free(myStruct);
				exit(EXIT_SUCCESS);
			case 'r':
				secR = (int) parseLong(optarg, argv);
				break;
			case 's':
				secS = (int) parseLong(optarg, argv);
				break;
			case 't':
				timesR = (int) parseLong(optarg, argv);
				break;
			case 'u':
				timesS = (int) parseLong(optarg, argv);
				break;
			case 'v':
				version("client");
				free(myStruct);
				exit(EXIT_SUCCESS);
			case 'x':
				strcpy(text,optarg);
				break;
			case '?':
				break;
			default:
				fprintf (stderr ,"%s:%s:%d:?? getopt returned character code 0%o ??\n",argv[0], __FILE__, __LINE__, c);
				break;
		}
	}

	if (optind < argc)
	{
		fprintf (stderr ,"%s:%s:%d: Non-valid argument.\n", argv[0], __FILE__, __LINE__);
		while (optind < argc)
		    printf("%s ", argv[optind++]);
		printf("\n");
	}

	if (pipe2(pipefd, FLAG) == -1)
	{
        perror("pipe");
        free(myStruct);
        exit(EXIT_FAILURE);
    }

    cpid = fork();

    switch(cpid)
    {
		case -1 :
			perror("fork");
			free(myStruct);
        	exit(EXIT_FAILURE);
		case 0 :
			close(pipefd[0]);

			if( pipe_message_set_text(myStruct, text) == -1)
			{
				fprintf (stderr ,"./pipe-main.out:%s:%d: Unable to set the \"%s\" message text.\n", __FILE__, __LINE__, text);
				free(myStruct);
				exit(EXIT_FAILURE);
			}

			if(pipe_message_set_pid(myStruct,getpid()) == -1)
			{
				fprintf (stderr ,"./pipe-main.out:%s:%d: Unable to set the \"%d\" pid.\n", __FILE__, __LINE__, getpid());
				free(myStruct);
				exit(EXIT_FAILURE);
			}

			if(timesS < 0 )
			{
				while(1)
				{
					write(pipefd[1], myStruct, PIPE_MESSAGE_TEXT_SIZE);
					pipe_message_print(*myStruct,"written");
					timesS--;
					if(secS <= 0)
					{
						printf("Press the Enter key to write...\n");
						getchar();
					}
					else sleep(secS);
		    	}
			}


			if(timesS >= 0 )
			{
				while(timesS > 0 )
				{
					write(pipefd[1], myStruct, PIPE_MESSAGE_TEXT_SIZE);
					pipe_message_print(*myStruct,"written");
					timesS--;
					if(secS <= 0)
					{
						printf("Press the Enter key to write...\n");
						getchar();
					}
					else sleep(secS);
				}
		    }
			close(pipefd[1]);
			break;
		default :
			if(pipe_message_set_pid(myStruct,cpid) == -1)
			{
				fprintf (stderr ,"./pipe-main.out:%s:%d: Unable to set the \"%d\" pid.\n", __FILE__, __LINE__, cpid);
				free(myStruct);
				exit(EXIT_FAILURE);
			}
		 	if(timesR<=0)
		 	{
				while(1)
				{
		    		if(secR <= 0)
					{
						printf("Press the Enter key to read...\n");
						getchar();
					}
					else sleep(secR);
					if (read(pipefd[0], myStruct, PIPE_MESSAGE_TEXT_SIZE) > 0)
					{
						pipe_message_print(*myStruct,"read");
					}
		   			close(pipefd[1]);
			   	}
			}
			if(timesR>0)
			{
				while(timesR>0)
				{
					if(secR <= 0)
					{
						printf("Press the Enter key to read...\n");
						getchar();
					}
					if (read(pipefd[0], myStruct, PIPE_MESSAGE_TEXT_SIZE) > 0)
					{
						pipe_message_print(*myStruct,"read");
					}
			   		close(pipefd[1]);
				   	sleep(secR);
					timesR--;
				}
			}
		 close(pipefd[0]);
		break;
    }

	return 0;
}

void help()
{
	printf("Usage: ./pipe-main.out [OPTION]...\nSend and receive messages through a pipe.\n\nOptions:\n\t");
	printf("-h, --help\n\t\tdisplay this help and exit\n\t");
	printf("-r, --seconds-for-receiving=SECONDS\n\t\tset the seconds between each try to receive a message (the default value is \"1\", a value less than or equal to 0 enables the interactive mode where the input stream is read)\n\t");
	printf("-s, --seconds-for-sending=SECONDS\n\t\tset the seconds between each try to send a message (the default value is \"1\", a value less than or equal to 0 enables the interactive mode where the input stream is read)\n\t");
	printf("-t, --times-for-receiving=TIMES\n\t\tset the number of times this program tries to receive a message (the default value is \"-1\", a negative value means repeat for ever)\n\t");
	printf("-u, --times-for-sending=TIMES\n\t\tset the number of times this program tries to send a message (the default value is \"1\", a negative value means repeat for ever)\n\t");
	printf("-v, --version\n\t\toutput version information and exit\n\t");
	printf("-x, --message-text=TEXT\n\t\tset the message text to TEXT (the default value is \"This is the default message text\")\n\n");
  printf("Report bugs to Bagre Gnebehi <bagre.gnebehi@etud.univ-pau.fr> and Awa Ndiaye <a.ndiaye@etud.univ-pau.fr>.\n");
}

void version()
{
	printf("pipe-main 1.0\n\nCopyright (C) 2018 Bagre Gnebehi and Awa Ndiaye.\n\nWritten by Bagre Gnebehi <bagre.gnebehi@etud.univ-pau.fr> and Awa Ndiaye <a.ndiaye@etud.univ-pau.fr>.\n");
}
