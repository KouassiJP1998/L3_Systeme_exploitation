#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <getopt.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <unistd.h>
#include <errno.h>
#include "msq-common.h"
#include "msq-message.h"

void help();
void freeMemory(char *pathname, char *text, msq_message_t *msg);

int main(int argc, char **argv)
{
	static struct option long_options[] =
	{
		{"help", no_argument, NULL, 'h'},
		{"version", no_argument, NULL, 'v'},
		{"message-type", required_argument, NULL, 'y'},
		{"key-proj-id", required_argument, NULL, 'i'},
		{"key-pathname", required_argument, NULL, 'p'},
		{"seconds", required_argument, NULL, 's'},
		{"message-text", required_argument, NULL, 'x'},
		{"times", required_argument, NULL, 't'}
    };

	int c,rc;
	int option_index = 0;
	msq_message_t *msg = malloc(sizeof(msq_message_t));
	int msqid;
	const int FLAG = 0666;
	int proj_id;
	char *pathname = malloc(sizeof(char)*10);
	long int type;
	char *text = malloc(sizeof(char)*32);
	int seconds;
	int times;
	type = 1;
	strcpy(text,"This is the default message text");
	seconds = 1;
	times = 1;
	proj_id = 1;
	strcpy(pathname,"file.ftok");

	while (1)
	{
		c = getopt_long(argc, argv, "i:p:s:t:y:x:hv", long_options, &option_index);
		if (c == -1)
			break;

		switch (c)
		{
			case 'v':
				version("client");
				freeMemory(pathname, text, msg);
				exit(EXIT_SUCCESS);
			case 'h':
				help();
				freeMemory(pathname, text, msg);
				exit(EXIT_SUCCESS);
			case 'i':
				proj_id = strtol(optarg,NULL,10);
				break;
			case 'p':
				pathname = optarg;
				break;
			case 's':
				seconds = strtol(optarg,NULL,10);
				break;
			case 't':
				times = strtol(optarg,NULL,10);
				break;
			case 'y':
				type = parseLong(optarg, argv);
				if (type == -1)
				{
					freeMemory(pathname, text, msg);
					exit(EXIT_FAILURE);
					break;
				}
				break;
			case 'x':
				text = (char *) realloc(text,sizeof(char)*strlen(optarg));
				strcpy(text,optarg);
				break;
			case '?':
				break;
			default:
				fprintf (stderr ,"%s:%s:%d:?? getopt returned character code 0%o ??\n",argv[0], __FILE__, __LINE__, c);
		}
	}

	if (optind < argc)
	{
		fprintf (stderr ,"%s:%s:%d: Non-valid argument.\n", argv[0], __FILE__, __LINE__);
		while (optind < argc)
		    printf("%s ", argv[optind++]);
		printf("\n");
	}

	if(msq_message_set_type(msg,type) == -1)
	{
		fprintf (stderr ,"./msq-client.out:%s:%d: Unable to set the \"%ld\" message type.\n", __FILE__, __LINE__, type);
		freeMemory(pathname, text, msg);
		exit(EXIT_FAILURE);
	}

	if(msq_message_set_text(msg,text) == -1)
	{
		fprintf (stderr ,"./msq-client.out:%s:%d: Unable to set the \"%s\" message text.\n", __FILE__, __LINE__, text);
		freeMemory(pathname, text, msg);
		exit(EXIT_FAILURE);
	}

	printf("proj_id = \"%d\"\npathname = \"%s\"\n",proj_id,pathname);

	msqid = createQueue(pathname, proj_id, FLAG, argv);
	if(msqid == -1)
	{
		freeMemory(pathname, text, msg);
		exit(EXIT_FAILURE);
	}

	while(times<0)
	{

  		rc = msgsnd(msqid, msg, sizeof(msg->text), IPC_NOWAIT|MSG_NOERROR);
  		if (rc >= 0)
  		{
    		msq_message_print(*msg);
  		}

		if(seconds <= 0)
		{
			printf("Press the Enter key to continue...");
			getchar();
		}
		else
			sleep(seconds);
	}

	while(times>0)
	{

  		rc = msgsnd(msqid, msg, sizeof(msg->text), IPC_NOWAIT|MSG_NOERROR);
  		if (rc >= 0)
  		{
    		msq_message_print(*msg);
  		}

		times--;
		if(seconds <= 0)
		{
			printf("Press the Enter key to continue...");
			getchar();
		}
		else
		{
			if(times > 0)
				sleep(seconds);
		}
	}

	freeMemory(pathname, text, msg);
	exit(EXIT_SUCCESS);
}

void help()
{
	printf("Usage: ./msq-client.out [OPTION]...\nSend a message to a server through a message queue.\n\nOptions:\n\t");
	printf("-h, --help\n\t\tdisplay this help and exit\n\t");
	printf("-i, --key-proj-id=PROJ_ID\n\t\tset the key project identifier to PROJ_ID (the default value is \"1\")\n\t");
	printf("-p, --key-pathname=PATHNAME\n\t\tset the key pathname to PATHNAME (the default value is \"file.ftok\")\n\t");
	printf("-s, --seconds=SECONDS\n\t\tset the seconds between each try (the default value is \"1\", a value less than or equal to 0 enables the interactive mode where the input stream is read)\n\t");
	printf("-t, --times=TIMES\n\t\tset the number of times this program tries to receive a message (the default value is\n\t\t\"-1\", a negative value means repeat for ever)\n\t");
	printf("-v, --version\n\t\toutput version information and exit\n\t");
	printf("-x, --message-text=TEXT\n\t\tset the message text to TEXT (the default value is \"This is the default message text\")\n\t");
	printf("-y, --message-type=TYPE\n\t\tset the message type to TYPE (the default value is \"1\")\n\n");
	printf("Report bugs to Bagre Gnebehi <bagre.gnebehi@etud.univ-pau.fr> and Awa Ndiaye <a.ndiaye@etud.univ-pau.fr>.\n");
}

void freeMemory(char *pathname, char *text, msq_message_t *msg)
{
	free(pathname);
	free(text);
	free(msg);
}
