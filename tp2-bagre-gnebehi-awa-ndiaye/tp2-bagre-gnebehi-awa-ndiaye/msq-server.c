#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <getopt.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <unistd.h>
#include <errno.h>
#include "msq-common.h"
#include "msq-message.h"

void help();
void freeMemory(char *pathname, msq_message_t *msg);

int main(int argc, char **argv)
{
	static struct option long_options[] =
	{
		{"help", no_argument, NULL, 'h'},
	   	{"version", no_argument, NULL, 'v'},
		{"key-proj-id", required_argument, NULL, 'i'},
		{"key-pathname", required_argument, NULL, 'p'},
		{"seconds", required_argument, NULL, 's'},
		{"times", required_argument, NULL, 't'}
	};

	int c,rc;
	int option_index;
	msq_message_t *msg = malloc(sizeof(msq_message_t));
	int msqid;
	const int FLAG = IPC_CREAT | IPC_EXCL | 0666;
	int proj_id;
	char *pathname = malloc(sizeof(char)*9);
	int seconds;
	int times;
	seconds = 1;
	times = -1;
	proj_id = 1;
	strcpy(pathname,"file.ftok");

	while (1)
	{
		option_index = 0;
		c = getopt_long(argc, argv, "i:p:s:t:hv", long_options, &option_index);
		if (c == -1)
			break;

		switch (c)
		{
			case '?':
				freeMemory(pathname, msg);
				exit(EXIT_FAILURE);
			case 'v':
				version("server");
				freeMemory(pathname, msg);
				exit(EXIT_SUCCESS);
			case 'h':
				help();
				freeMemory(pathname, msg);
				exit(EXIT_SUCCESS);
			case 'i':
				proj_id =  strtol(optarg,NULL,10);
				break;
			case 'p':
				pathname = (char *) realloc(pathname,sizeof(char)*strlen(optarg));
				strcpy(pathname,optarg);
				break;
			case 's':
				seconds = strtol(optarg,NULL,10);
				break;
			case 't':
				times = strtol(optarg,NULL,10);
				break;
			default:
				fprintf (stderr ,"%s:%s:%d:?? getopt returned character code 0%o ??\n",argv[0], __FILE__, __LINE__, c);
		}
	}

	if (optind < argc)
	{
		fprintf (stderr ,"%s:%s:%d: Non-valid argument.\n", argv[0], __FILE__, __LINE__);
		while (optind < argc)
			printf("%s ", argv[optind++]);
		printf("\n");
		freeMemory(pathname, msg);
		exit(EXIT_FAILURE);
	}

	printf("proj_id = \"%d\"\npathname = \"%s\"\n",proj_id,pathname);

	msqid = createQueue(pathname, proj_id, FLAG, argv);
	if(msqid == -1)
	{
		freeMemory(pathname, msg);
		exit(EXIT_FAILURE);
	}

	if(times<0)
	{
		while(1)
		{
			if(seconds <= 0)
			{
				printf("Press the Enter key to continue...");
				getchar();
			}
			else sleep(seconds);

			rc = msgrcv(msqid, msg, sizeof(msg->text), 0, IPC_NOWAIT|MSG_NOERROR);
			if (rc >= 0)
			{
				msq_message_print(*msg);
			}
		}
	}

	if(times>=0)
	{
		while(times>0)
		{
			if(seconds <= 0)
			{
				printf("Press the Enter key to continue...");
				getchar();
			}
			else sleep(seconds);

			rc = msgrcv(msqid, msg, sizeof(msg->text), 0, IPC_NOWAIT|MSG_NOERROR);
			if (rc >= 0)
			{
				msq_message_print(*msg);
			}

			times--;
		}
	}

	if (msgctl(msqid, IPC_RMID, NULL) == -1)
	{
		fprintf (stderr ,"%s:%s:%d: Unable to delete the queue.\n",argv[0], __FILE__, __LINE__);
		freeMemory(pathname, msg);
		exit(EXIT_FAILURE);
	}

	freeMemory(pathname, msg);
	exit(EXIT_SUCCESS);
}

void help()
{
	printf("Usage: ./msq-server.out [OPTION]...\nReceive messages from clients through a message queue.\n\nOptions:\n\t");
	printf("-h, --help\n\t\tdisplay this help and exit\n\t");
	printf("-i, --key-proj-id=PROJ_ID\n\t\tset the key project identifier to PROJ_ID (the default value is \"1\")\n\t");
	printf("-p, --key-pathname=PATHNAME\n\t\tset the key pathname to PATHNAME (the default value is \"file.ftok\")\n\t");
	printf("-s, --seconds=SECONDS\n\t\tset the seconds between each try (the default value is \"1\", a value less than or equal to 0 enables the interactive mode where the input stream is read)\n\t");
	printf("-t, --times=TIMES\n\t\tset the number of times this program tries to receive a message (the default value is\n\t\t\"-1\", a negative value means repeat for ever)\n\t");
	printf("-v, --version\n\t\toutput version information and exit\n\n\t");
	printf("Report bugs to Bagre Gnebehi <bagre.gnebehi@etud.univ-pau.fr> and Awa Ndiaye <a.ndiaye@etud.univ-pau.fr>.\n");
}

void freeMemory(char *pathname, msq_message_t *msg)
{
	free(pathname);
	free(msg);
}
