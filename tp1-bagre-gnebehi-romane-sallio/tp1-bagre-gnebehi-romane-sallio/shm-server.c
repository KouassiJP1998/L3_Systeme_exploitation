#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <time.h>
#include <unistd.h>
#include "shm-message.h"
#include "shm-common.h"

int main(int argc, char **argv){
   int c;
   int PROJ_ID = 1;
   char *PATHNAME = "file.ftok";
   int SECONDS = 1;
   int TIMES = -1;
   shm_message_t *pShmMessage;
   int option_index = 0;
   int shmid;
   int server = 1;

   static struct option long_options[] = {
       {"help",     no_argument, 0,  'h' },
       {"key-proj-id",     required_argument, 0,  'i' },
       {"key-pathname",     required_argument, 0,  'p' },
       {"seconds",     required_argument, 0,  's' },
       {"times",     required_argument, 0,  't' },
       {"version",     no_argument, 0,  'v' }
   };

   /*Récupération des arguments*/
   c = getopt_long(argc, argv, "hi:p:s:t:v", long_options, &option_index);
   while(c != -1){
       switch (c) {
           case 'h':
               printf("Usage: ./shm-server.out [OPTION]...\n Receive messages from clients through shared memory.\n");
               printf("Options:\n -h, --help\n         display this help and exit \n");
               printf(" -i, --key-proj-id=PROJ_ID\n          set the key project identifier to PROJ_ID (the default value is \"1\")\n");
               printf(" -p, --key-pathname=PATHNAME\n          set the message name to NAME (the default value is \"Default name\") \n");
               printf(" -s, --seconds=SECONDS\n          set the seconds between each try (the default value is \"1\", a value less than or equal\n to 0 enables the interactive mode where the input stream is read)\n");
               printf(" -t, --times=TIMES\n          set the number of times this program tries to receive a message (the default value is\"-1\", a negative value means repeat for ever) \n");
               printf(" -v, --version\n          output version information and exit\n");
               printf("Report bugs to Bagre Gnebehi <bagre.gnebehi@etud.univ-pau.fr> and Romane Sallio <romane.sallio@etud.univ-pau.fr>.\n");
               exit(0);
           break;
           case 'i':
              PROJ_ID = atoi(optarg);
           break;
           case 'p':
              PATHNAME = optarg;
           break;
           case 's':
              SECONDS = atoi(optarg);
           break;
           case 't':
              TIMES = atoi(optarg);
           break;
           case 'v':
              printf("shm-server 20180309\nCopyright (C) 2018 Bagre Gnebehi and Romane Sallio.\n");
              printf("Written by Bagre Gnebehi <bagre.gnebehi@etud.univ-pau.fr> and Romane Sallio <romane.sallio@etud.univ-pau.fr>.\n");
              exit(0);
           break;
      }
      c = getopt_long(argc, argv, "hi:p:s:t:v", long_options, &option_index);
   }

   pShmMessage = createpShmMessage(PATHNAME,PROJ_ID, argv[0], server);

   /*Boucle d'attente*/
   while(TIMES != 0){
     /*Vérification message non vide*/
     sleep(SECONDS);
     if(shm_message_is_empty(*pShmMessage) != 0){
       /*Mode intercatif*/
       if(SECONDS <= 0){
         printf("Press the Enter key to continue...");
         /*Attend une saisie de l'utilisateur*/
         getchar();
       }
     }else{
       /*Affiche le message*/
       shm_message_print(*pShmMessage);
       shm_message_empty(pShmMessage);

     }
     TIMES--;
   }
   /*Suppression du segement de mémoire partagée */
   server = 0;
   shmid = createId(PATHNAME,PROJ_ID, argv[0], server);
   if (shmctl(shmid, IPC_RMID, NULL) == -1) {
		   fprintf (stderr ,"%s:%s:%d: Unable to delete the shared memory.\n",argv[0], __FILE__, __LINE__);
		  exit(1);
	 }
   exit(0);
}
